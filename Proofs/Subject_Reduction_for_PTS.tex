\documentclass[reqno]{amsart}
\input{preamble.sty}
\input{macros.sty}

\begin{document}
    \title{Subject Reduction for Pure Type Systems}
    \author{Zhaoshen Zhai}
    \address{Department of Mathematics and Statistics, McGill University, 805 Sherbrooke Street West, Montreal, QC, H3A 0B9, Canada}
    \email{zhaoshen.zhai@mail.mcgill.ca}
    \date{\today}
    \thanks{Notes for a project for \textsc{Comp527: Logic and Computation} taught by Professor Brigitte Pientka, with Charlotte Marchal, Dashiell Rich and Milton Rosenbaum.}

    \begin{abstract}
        Following \cite{SU06}, we give a detailed proof of \textit{subject reduction} for arbitrary \textit{pure type systems}, which abstract and generalize many of the basic constructs found in, say, the simply-typed $\lambda$-calculus, the polymorphic $\lambda$-calculus (System \textbf{F}), the $\lambda$-calculus of dependent types $\lambda\mathbf{P}$, and much more.
    \end{abstract}

    \maketitle

    \subsection*{Introduction}

    Subject reduction is a crucial property of a type system that guarantees its `computational consistency' by ensuring that reductions of a well-typed expression remains well-typed, and which supports the slogan that `well-typed programs do not go wrong'. It is thus desirable that we can prove it uniformly across many different type systems, which is the goal of this note.

    To this end, we start from the beginning\footnote{As Professor Pientka would say: `We'll start slow'.} with the \textit{simply-typed $\lambda$-calculus} $\lambda_\rightarrow$, in which we prove subject reduction. We then progress to more complicated type systems (in particular, System \textbf{F} and $\lambda\mathbf{P}$) to illustrate some more subtleties and concepts not present in $\lambda_\rightarrow$, and finally define \textit{pure type systems} and prove subject reduction therein. We will not discuss any of these systems in length (or, at all...), but refer the interested reader to \cite{SU06} for general type theory and \cite{Bar91} for the motivation and applications of pure type systems.\\

    Throughout, fix a countably infinite set $V$, whose element we call \textit{variables}. For each of the following type systems, there will be a notion of `types' and `terms'. Once they are defined, we can speak of the following:

    \begin{definition*}
        A \textit{context} is a finite set $\Gamma\coloneqq\l\{x_1:\tau_1,\dots,x_n:\tau_n\r\}$ of pairs $(x_i:\tau_i)$, where each $x_i\in V$ and each $\tau_i$ is a `type'. If $(x:\tau)\in\Gamma$, we write $\Gamma(x)=\tau$, and we let
        \begin{equation*}
            \dom\Gamma\coloneqq\l\{x\in V\st(x:\tau)\textrm{ for some `type' }\tau\r\}\ \ \ \ \textrm{and}\ \ \ \ \im\Gamma\coloneqq\l\{\tau\textrm{ `type'}\st(x:\tau)\in\Gamma\textrm{ for some }x\in V\r\}.
        \end{equation*}
        A \textit{judgement} is a triple $\Gamma\proves M:\tau$ consisting of a context $\Gamma$, a `term' $M$, and a `type' $\tau$.
    \end{definition*}

    \section{The Simply-typed $\lambda$-calculus}

    \begin{definition}
        A \textit{simple type} is a propositional formula in the language $\rightarrow$.
    \end{definition}

    \begin{definition}
        A \textit{$\lambda$-term} is a string defined by the grammar $M\coloneqq x\,|\,M\,M\,|\,(\lambda x\,M)$. We denote by $\Lambda$ the set of $\lambda$-terms. The set of \textit{free variables} of a $\lambda$-term $M$ is defined inductively by
        \begin{equation*}
            FV(x)\coloneqq\l\{x\r\},\ \ \ \ FV(\lambda x\,M)\coloneqq FV(M)\comp\l\{x\r\},\ \ \ \ FV(MN)\coloneqq FV(M)\cup FV(N).
        \end{equation*}
    \end{definition}

    \begin{notation}
        We always consider $\lambda$-terms under $\alpha$-conversion. Basically, we can freely change the bound variable $x$ in $\lambda x$ without modifying the term.
    \end{notation}

    \begin{definition}
        We say that a judgement $\Gamma\proves M:\tau$ is \textit{derivable in $\lambda_\rightarrow$} if there is a finite tree of judgements rooted at $\Gamma\proves M:\tau$, whose leaves are instances of \textsc{Var}, and such that the children of each internal node is obtained from the rules \textsc{Abs} or \textsc{App} read bottom-up.
        \begin{equation*}
            \infer[\mathsc{Var}]{\Gamma,x:\tau\proves x:\tau}{}\ \ \ \ 
            \infer[\mathsc{Abs}]{\Gamma\proves(\lambda x\,M):\sigma\rightarrow\tau}{\Gamma,x:\sigma\proves M:\tau}\ \ \ \ 
            \infer[\mathsc{App}]{\Gamma\proves(M\,N):\tau}{
                \Gamma\proves M:\sigma\rightarrow\tau &
                \Gamma\proves N:\sigma
            }
        \end{equation*}
        The rules \textsc{Abs} and \textsc{App} can only be applied when $x\not\in\dom\Gamma$.
    \end{definition}

    \begin{lemma}[Generation Lemma for $\lambda_\rightarrow$]\label{lem:simply_typed_generation}
        Suppose that\footnote{When we assert `$\Gamma\proves M:\tau$', we mean that it is derivable in the current type system under consideration.} $\Gamma\proves M:\tau$.
        \begin{enumerate}
            \item If $M=x$, then $\Gamma(x)=\tau$.
            \item If $M=PQ$, then $\Gamma\proves P:\sigma\rightarrow\tau$ and $\Gamma\proves Q:\sigma$ for some type $\sigma$.
            \item If $M=\lambda x\,N$ and $x\not\in\dom\Gamma$, then $\tau=\tau_1\rightarrow\tau_2$ and $\Gamma,x:\tau_1\proves N:\tau_2$ for some types $\tau_1,\tau_2$.
        \end{enumerate}
    \end{lemma}
    \begin{proof}
        Since the root of the derivation tree for $\Gamma\proves M:\tau$ determines the shape of $M$, we see that (1) follows from \textsc{Var} and (2) follows from \textsc{App}. For (3), the child of the root must be obtained from \textsc{Abs} and is of the form $\Gamma,x':\tau_1\proves N':\tau_2$, where $\lambda x\,N=\lambda x'\,N'$. Clearly $\tau=\tau_1\rightarrow\tau_2$. Moreover, note that $N'=N[x'/x]$, so $\Gamma,x':\tau_1\proves N[x'/x]:\tau_2$, and finally substituting $x$ for $x'$ back gives $\Gamma,x:\tau_1\proves N:\tau_2$, as desired.
    \end{proof}

    \begin{lemma}[Change of Context]\label{lem:simply_typed_change_of_context}
        If $\Gamma\proves M:\tau$ and $\Gamma(x)=\Gamma'(x)$ for all $x\in FV(M)$, then $\Gamma'\proves M:\tau$.
    \end{lemma}
    \begin{proof}
        By induction on $M$. If $M=x$, then $\Gamma'(x)=\Gamma(x)=\tau$ by Lemma \ref{lem:simply_typed_generation}.1, and hence $\Gamma'\proves x:\tau$ by \textsc{Var}. If $M=PQ$, then by Lemma \ref{lem:simply_typed_generation}.2, we have $\Gamma\proves P:\sigma\rightarrow\tau$ and $\Gamma\proves Q:\sigma$ for some type $\sigma$. By induction, we see that $\Gamma'\proves P:\sigma\to\tau$ and $\Gamma'\proves Q:\sigma$, on which \textsc{App} gives $\Gamma'\proves M:\tau$. Lastly, if $M=\lambda x\,N$, we can choose $x\not\in\dom\Gamma\cup\dom\Gamma'$, so that $\tau=\tau_1\rightarrow\tau_2$ and $\Gamma,x:\tau_1\proves N:\tau_2$ by Lemma \ref{lem:simply_typed_generation}.3. By induction, we see that $\Gamma',x:\tau_1\proves N:\tau_2$, on which \textsc{Abs} gives the desired as $\Gamma'\proves M:\tau$.
    \end{proof}

    \begin{lemma}[Substitution Lemma for $\lambda_\rightarrow$]
        If $\Gamma,x:\tau\proves M:\sigma$ and $\Gamma\proves N:\tau$, then $\Gamma\proves M[N/x]:\sigma$.
    \end{lemma}
    \begin{proof}
        By induction on $M$. If $M=y$ and $x\neq y$, then $\Gamma(y)=\sigma$ and $M[N/x]=y$, so that $\Gamma\proves y:\sigma$ by \textsc{Var}. If $x=y$, then $\Gamma(x)=\tau$ and $M[N/x]=N$, so $\sigma=\tau$ and $\Gamma\proves N:\tau$ by assumption. If $M=PQ$, then by Lemma \ref{lem:simply_typed_generation}.2, we have $\Gamma,x:\tau\proves P:\rho\rightarrow\sigma$ and $\Gamma,x:\tau\proves Q:\rho$ for some type $\rho$. By induction, we see that $\Gamma\proves P[N/x]:\rho\to\sigma$ and $\Gamma\proves Q[N/x]:\rho$, on which \textsc{App} gives $\Gamma\proves M[N/x]:\sigma$.

        If $M=\lambda y\,M'$ where $y\not\in\dom(\Gamma,x:\tau)$, then by Lemma \ref{lem:simply_typed_generation}.3 we have $\sigma=\sigma_1\rightarrow\sigma_2$ and $\Gamma,x:\tau,y:\sigma_1\proves M':\sigma_2$ for some types $\sigma_1,\sigma_2$. By Lemma \ref{lem:simply_typed_change_of_context}, we can weaken $\Gamma\proves N:\tau$ to $\Gamma,y:\sigma_1\proves N:\tau$, so by induction\footnote{Note that our contexts are unordered, so we have exchange implicitly.} we have $\Gamma,y:\sigma_1\proves M'[N/x]:\sigma_2$, and we can apply \textsc{Abs} to get $\Gamma\proves M[N/x]:\sigma$, as desired.
    \end{proof}

    \begin{definition}
        A relation $\esup$ on $\Lambda$ is \textit{compatible} if for any $M,N\in\Lambda$ with $M\esup N$, we have $MP\esup NP$ and $PM\esup PN$ for each $P\in\Lambda$, and $\lambda x\,M\esup\lambda x\,N$ for each $x\in V$.

        The least compatible relation $\rightarrow_\beta$ on $\Lambda$ such that $(\lambda x\,M)N\rightarrow_\beta M[N/x]$ is called \textit{$\beta$-reduction}.
    \end{definition}

    \begin{notation}
        For any relation $\rightarrow_\blob$ on a set $X$, we let $\rightarrow_\blob^+$ denote the transitive closure, let $\rightarrow_\blob^\ast$ denote the transitive and reflexive closure, and let $=_\blob$ denote the least equivalence relation containing $\rightarrow_\blob$.
    \end{notation}

    \begin{theorem}[Subject Reduction for $\lambda_\rightarrow$]
        If $\Gamma\proves M:\sigma$ and $M\twoheadrightarrow_\beta N$, then $\Gamma\proves N:\sigma$.
    \end{theorem}
    \begin{proof}
        \TODO
    \end{proof}

    \section{The polymorphic $\lambda$-calculus: System $\mathbf{F}$}

    \begin{definition}
        
    \end{definition}

    \begin{lemma}
        
    \end{lemma}

    \begin{theorem}[Subject Reduction for $\mathbf{F}$]

    \end{theorem}

    \section{Dependent Types: $\lambda\mathbf{P}$}

    \begin{definition}
        
    \end{definition}

    \begin{lemma}
        
    \end{lemma}

    \begin{theorem}[Subject Reduction for $\lambda\mathbf{P}$]

    \end{theorem}

    \section{The $\lambda$-cube and beyond: Pure Type Systems}

    \begin{definition}
        
    \end{definition}

    \begin{lemma}
        
    \end{lemma}

    \begin{theorem}[Subject Reduction for Pure Type Systems]
        
    \end{theorem}

    \begin{bibdiv}
        \begin{biblist}*{labels={alphabetic}}
            \bibselect{bibliography}
        \end{biblist}
    \end{bibdiv}
\end{document}
