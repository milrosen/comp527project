First-Order Logic
% 

i : type. % Type of individuals; we leave elements abstract.

LF o : type =  % formulas
  | ⊃ : o -> o -> o
  | ⊤ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
  | ¬  : o -> o
  | ∀  : (i → o) → o     % ∀ \x. A(x) ⊃ B    ∀ \x. A(x) ⊃ B(x) 
  | ∃  : (i → o) → o     % ∃ \x. A(x) ⊃ B    ∃ \x. A(x) ⊃ B(x) 
;

--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.

%{

 Natural deduction

}%
LF nd : o -> type = 
  | ⊃I : (nd A -> nd B)
	 -> nd (A ⊃ B)
	       
  | ⊃E : nd (A ⊃ B) -> nd A 			  
	 -> nd B
	       
  | ¬I : ({p:o} nd A -> nd p)
	 -> nd (¬ A)
	       
  | ¬E : nd (¬ A) -> nd A
	 -> nd C
	       
  | ∧I : nd A → nd B
	 → nd  (A ∧ B)
	       
  | ∧El : nd (A ∧ B)
	  → nd A

  | ∧Er : nd (A ∧ B)
	  → nd B

  | ∨Il : nd A
	  → nd (A ∨ B)
  | ∨Ir : nd B → nd (A ∨ B)
  | ∨E  :  nd (A ∨ B)
        → (nd A → nd C)
        → (nd B → nd C)        
        → nd C
  | ⊤I : nd ⊤

  | ∀I : ({a:i} nd (A a))   % for a fresh/new parameter a:i
	                    % (assuming such an indivudal a exists), prove nd (A a)
                            %  this means we replace the bound variable in A
	                    %  with a fresn/new parameter a
	 → nd (∀ (\x. A x))     % Note : A has type i → o

  | ∀E : {T:i} nd (∀ A)  % ∀ \x. A x  === exploiting A : i → o = \x. A x 
	 → nd (A T)      % Since A has type i → o, we can apply it to an individual T

  | ∃I : {T:i} nd (A T)           
	 → nd (∃ A)     % ∃ \x. A x   === exploiting A : i → o = \x:i. A x  : i → o 

  | ∃E : nd (∃ \x. A x)       % ∃ \x. A x
	 → ({a:i} nd (A a) → nd C)
	 → nd C
;

%{
Classical Natural Deduction, with the byContra rule

      ---------- u 
        ¬ A true

 
         p true 
----------------------byContra 
     A true
}%
LF cnd : o -> type = 
  | ⊃cI : (cnd A -> cnd B)
	 -> cnd (A ⊃ B)
  | ⊃cE : cnd (A ⊃ B) -> cnd A
	 -> cnd B
  | ¬cI : ({p:o} cnd A -> cnd p)
	 -> cnd (¬ A)
  | ¬cE : cnd (¬ A) -> cnd A
	 -> cnd C
  | ∧cI : cnd A → cnd B → cnd  (A ∧ B)
  | ∧cEl : cnd (A ∧ B) → cnd A
  | ∧cEr : cnd (A ∧ B) → cnd B
  | ∨cIl : cnd A → cnd (A ∨ B)
  | ∨cIr : cnd B → cnd (A ∨ B)
  | ∨cE  :  cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C
  | ⊤cI : cnd ⊤
  | byContra: ({p:o}cnd (¬ A) → cnd p)
	 → cnd A
	 
;


rec u0 : [ ⊢ nd (∀ (\x. A[x] ⊃ A[x]))] = 
[ ⊢ ∀I \a. (⊃I \u. u)] ;


%{ 

% This will not check, since it is not a valid proof.

rec false_u : [ ⊢ nd (∀ \a. (∀ \b. A[a] ⊃ A[b]))] =
[ ⊢  ∀I \a. (∀I \b. (⊃I \u.u))
];
}%


rec u1 : [ ⊢ nd ((∀ (\x. A[x] ∧ B[x])) ⊃  ((∀ \x.A[x]) ∧ (∀ \x.B[x]))) ] =
[ ⊢ ⊃I \u. % (∀ \x.A[x] ∧ B[x]) true
       (∧I  (∀I \a. ∧El (∀E a u))   % prove : ∀ a. A[a]
  	    (∀I \a. ∧Er (∀E a u))  % prove : ∀ a. B[a] 
       )
]
;


rec u2 : [ ⊢ nd (∀ \x. (∃ \y.  P[x]  ⊃ P[y]))] =
[ ⊢ ∀I \a. ∃I a (⊃I \u. u) 
]
;

rec uex1 : [ ⊢ nd (∀ \x. ∃ \y. P[x] ⊃ P[y])] =
 [ ⊢ ∀I \x. (∃I x (⊃I \u.u)) ]
;

rec uex2 : [ ⊢ nd ((∃ \x. A[x] ∨ B[x]) ⊃  (∃ \x. A[x])   ∨   (∃ \x.B[x]) ) ] =
[ ⊢ ⊃I \u .  % (∃ \x. A[x] ∨ B[x])
       (∃E u (\a. \v. % A[a] ∨ B[a]
		  (∨E v   (\ha. ∨Il (∃I a ha)) (\hb. ∨Ir (∃I a hb))
		  )
	     )
	 )
];

rec uex3 : [ ⊢ nd ((∃ \x. ¬ A[x]) ⊃ ¬ (∀ \x. A[x]))] =
[ ⊢ ⊃I \u. % (∃ \x. ¬ A[x]) true 
       (¬I \p.\v. % ∀ \x. A[x] true
	   (∃E u (\b.\w. % ¬ A[b] true
		     (¬E w (∀E b v)))
	   ) 
       )
];


rec uex4 : [ ⊢ nd (((∃ \x. A[x]) ⊃ B[]) ⊃ (∀ \x. A[x] ⊃ B[]))] =
[ ⊢ ⊃I \u . % ((∃ \x. A[x]) ⊃ B[]) true
       (∀I \a. % a:i
	   (⊃I \v. % A[a] true
	       (⊃E u (∃I a v))   % to prove : B[] true
	   ) 
       ) 
]
;


rec uex5 : [ ⊢ nd ((∀ \x. A[x] ⊃ B[]) ⊃ ((∃ \x. A[x]) ⊃ B[]))] =
[ ⊢ ⊃I (\u. % (∀ \x. A[x] ⊃ B[]) true
	⊃I (\v. % (∃ \x. A[x]) true
	    ∃E v (\a.\w.  % a:i and w: A[a] true
		     ⊃E (∀E a u) w
		 ) 	     
	   )
       )
]
;    


rec qa : [ ⊢ nd (((A ⊃ B) ∧ (A ∨ C)) ⊃ (B ∨ C)) ] = 
[ ⊢ ⊃I \u . ∨E (∧Er u) 
       (\x . ∨Il (⊃E (∧El u) x)) 
       (\y . ∨Ir y)] ;

rec qb : [ ⊢ nd ((A ∧ ¬ B) ⊃ ¬(A ⊃ B))] = 
[ ⊢ ⊃I \u . ¬I \p.\v. ¬E (∧Er u) (⊃E v (∧El u))] ;

rec qc : [ ⊢ cnd ( ¬(A ⊃ B) ⊃ (A ∧ ¬ B))] =  
[ ⊢ ⊃cI \u . byContra \p.\v. ¬cE u 
       (⊃cI \w . byContra \q.\x. ¬cE v (∧cI w x))];

rec qd : [ ⊢ nd ((∀ \x.P[x] ∧ ¬ Q[x]) ∧ (∃\x.R[x] ⊃ Q[x]) ⊃ ∃ \x. ¬ R[x] ∧ P[x])] = 
[ ⊢ ⊃I \u . ∃E (∧Er u) \a.\v. ∃I a (∧I 
       (¬I \p.\w. ¬E (∧Er (∀E a (∧El u))) (⊃E v w)) 
       (∧El (∀E a (∧El u))))] ;
	   
rec qe : [ ⊢ nd  ((∀ \y.∀ \x.P[x] ∧ Q[x,y]) ⊃  ∀ \x. ((∀ \y.Q[y,x]) ∧ P[x]))] = 
[ ⊢ ⊃I \u . ∀I \a. ∧I 
       (∀I \b . ∧Er (∀E b (∀E a u)))
       (∧El (∀E a (∀E a u)))] ;

rec qf : [ ⊢ nd ((∀ \x. (¬ P[x] ∨  Q[x])) ⊃ ∀ \x.P[x] ⊃ Q[x]) ] = 
[ ⊢ ⊃I \u . ∀I \a . ∨E (∀E a u) 
       (\v . ⊃I \p. ¬E v p)
       (\w . ⊃I \p. w)] ;

rec qg : [f:i → i ⊢ nd ((∀ \x.P[x] ⊃ P[f(x)]) ⊃ (∀ \x.P[x] ⊃ P[f(f(x))] ))] = 
[ f : i → i ⊢ ⊃I \u . ∀I \a. ⊃I \pa . 
       ⊃E (∀E (f a) u) (⊃E (∀E a u) pa) ] ; 
