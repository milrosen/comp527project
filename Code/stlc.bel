LF s : type =
    | star : s
    | box : s
;

LF axioms : s → s → type =
    | axi : axioms star box
;

LF rules : s → s → s → type =
    | rule : rules star star star
;

LF o : type =
    | lam : o → (o → o) → o
    | pi : o → (o → o) → o
    | app : o → o → o
    | const : s → o
;

LF value : o → type = 
    | const_v : value (const s1)
    | lam_v   : value v → value (lam v M)
    | pi_v    : value v → value (pi v M)
;
LF step : o → o → type =
    | e_app_lam : value M → step (app (lam T N) M) (N M)
    | e_app_1 : step M M' → step (app M N) (app M' N)
    | e_app_2 : step N N' → step (app M N) (app M N')
    | e_lam_1 : step T T' → step (lam T M) (lam T' M) 
    | e_lam_2 : step M M' → step (lam T \x.M) (lam T \x.M') 
    | e_pi_1  : step T T' → step (pi T M) (pi T' M)
    | e_pi_2  : step M M' → step (pi T \x.M) (pi T \x.M')
;

LF pts : o → o → type =
    | axiom : axioms s1 s2 → pts (const s1) (const s2)
    | App : pts F (pi A B) → pts a A → 
        pts (app F a) (B a)

    | ΠI : rules s1 s2 s3 → 
        pts A (const s1) → ({x : o} pts x A → pts (B x) (const s2)) →
        % ---
        pts (pi A B) (const s3)

    | λI : rules s1 s2 s3 → 
        pts A (const s1) → ({x : o} pts x A → pts (m x) (B x)) →  ({x : o} pts x A → pts (B x) (const s2)) →
        % ---
        pts (lam A m) (pi A B)
    | Conv : pts B C' → pts C' (const s1) → step C C' → pts B C
;

% notLam: o → type.
% n_app: notLam (app M N).

% solid chance I delete this, remains to be seen

schema ctx = some [A:o, S:s, P : pts A (const S)] block (x:o, A:o, d : pts x A);


% preservation: if Γ ⊢ A : B and A → A', then Γ ⊢ A' : B
% would need to prove that the two terms C and C' aren't literally the same
% but are beta equiv.
rec pres: {Γ:ctx} [Γ ⊢ pts B C] → [Γ ⊢ step B B'] → [Γ ⊢ pts B' C] = 
/ total st (pres _ _ _ d st)/
mlam Γ => fn d => fn st => case d of 
| [Γ ⊢ App D1 D2] => 
    (case st of     
    | [Γ ⊢ e_app_lam S1] => 
        % let [Γ ⊢ λI R A (\x.\d.M) (\x.\d.B)] = [Γ ⊢ D1] in ? 
        ?
    | [Γ ⊢ e_app_1 S1] => 
        let [Γ ⊢ D1'] = pres [Γ] [Γ ⊢ D1] [Γ ⊢ S1] in
        [Γ ⊢ App D1' D2]
    | [Γ ⊢ e_app_2 S2] => 
        let [Γ ⊢ D2'] = pres [Γ] [Γ ⊢ D2] [Γ ⊢ S2] in 
        % in this case, we need to use the conversion rule inside the bound term. 
        % like, since we know that a -> a', and that B : C[a], we wanna say that B : C[a']
        % this might require multistep, since if a is a redex, then C[a'] take way more steps
        % to reduce, if a' is going everywhere.
        % unfortunately, we can't even access the C, and before we can use Conv, we need to
        % show that C : s_n  
        ?
    )
| [Γ ⊢ ΠI R D1 \x.\d.D2] => ?
| [Γ ⊢ λI R D1 (\x.\d.D2) (\x.\d.D3) ] => 
    (case st of 
    | [Γ ⊢ e_lam_1 S1] => 
        let [Γ ⊢ D1'] = pres [Γ] [Γ ⊢ D1] [Γ ⊢ S1] in
        % [Γ ⊢ λI R D1' (\x.\d.D2) (\x.\d.D3)]
        ?
    | [Γ ⊢ e_lam_2 S2] => 
        % let [Γ, b:block x:o, T:o, d:pts x T ⊢ D2'[.., b.1, b.2]] = 
        % pres [Γ, b:block x:o, T:o, d:pts x T]
        %     %  [Γ, b ⊢ D2[..]] 
        %      [Γ, b ⊢ S2] in 
        ?
    )
| [Γ ⊢ Conv D1 D2 S2] => 
    let [Γ ⊢ D1'] = pres [Γ] [Γ ⊢ D1] st in 
    [Γ ⊢ Conv D1' D2 S2]
| [Γ ⊢ axiom axi] => 
    impossible st
| [Γ ⊢ #p.3] => 
    % pres [Γ] d st
    ?
;