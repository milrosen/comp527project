LF s : type =
    | star : s
    | box : s
;

LF axioms : s → s → type =
    | axi : axioms star box
;

LF rules : s → s → s → type =
    | rule : rules star star star
;

LF o : type =
    | lam : o → (o → o) → o
    | pi : o → (o → o) → o
    | app : o → o → o
    | const : s → o
;

LF pts : o → o → type =
    | axiom : axioms s1 s2 → pts (const s1) (const s2)
    | App : pts F (pi A B) → pts a A → 
        pts (app F a) (B a)

    | ΠI : rules s1 s2 s3 → 
        pts A (const s1) → ({x : o} pts x A → pts (B x) (const s2)) →
        % ---
        pts (pi A B) (const s3)

    | λI : rules s1 s2 s3 → 
        pts A (const s1) → ({x : o} pts x A → pts (m x) (B x)) →  ({x : o} pts x A → pts (B x) (const s2)) →
        % ---
        pts (lam A m) (pi A B)
;

% notLam: o → type.
% n_app: notLam (app M N).

% solid chance I delete this, remains to be seen
LF value : o → type = 
    | const_v : value (const s1)
    | lam_v   : value v → value (lam v M)
    | pi_v    : value v → value (pi v M)
;
LF step : o → o → type =
    | e_app_1 : step M M'           → step (app M N) (app M' N)
    | e_app_2 : step N N' → value M → step (app M N) (app M N')
    | e_app_lam : value M → step (app (lam T N) M) (N M)
    % | e_app_pi  : value M → step (app (pi  T N) M) (N M)
;



schema ctx = some [A:o, S:s, P : pts A (const S)] block (x:o, d : pts x A);
% preservation: if Γ ⊢ A : B and A → A', then Γ ⊢ A' : B

rec pres: {Γ:ctx} [Γ ⊢ pts B C] → [Γ ⊢ step B B'] → [Γ ⊢ pts B' C] = 
/ total s (pres _ _ _ d s)/
mlam Γ => fn d => fn s => case s of 
| [Γ ⊢ e_app_1 S1] => 
    let [Γ ⊢ App D1 D2] = d in
    let [Γ ⊢ D1'] = pres [Γ] [Γ ⊢ D1] [Γ ⊢ S1] in 
    [Γ ⊢ App D1' D2]

| [Γ ⊢ e_app_2 S2 _] =>
    let [Γ ⊢ App D1 D2] = d in
    let [Γ ⊢ D2'] = pres [Γ] [Γ ⊢ D2] [Γ ⊢ S2] in
    % [Γ ⊢ App D1 D2']
    ?
| [Γ ⊢ e_app_lam V] => 
     let [Γ ⊢ App D1 D2] = d in 
    %  let [Γ ⊢ ]
    ?
% | [Γ ⊢ e_app_pi  V] => ?
;